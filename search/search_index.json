{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"qcextender","text":"<p>qcextender is a Python package for extending and unifying gravitational waveform generation across libraries such as PyCBC, lalsimulation, and SXS. It provides a shared interface for handling metadata, performing unit conversions between dimensionless and physical (SI) representations, and managing consistent waveform transformations and match calculations.</p> <p>The goal is to make it straightforward to load, compare, and analyze waveforms from different sources under a consistent, physically meaningful framework.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#using-uv","title":"Using uv","text":"<pre><code>uv pip install git+https://github.com/aminrouanserik/qcextender.git\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import matplotlib.pyplot as plt\nfrom qcextender.waveform import Waveform\nfrom qcextender.dimensionlesswaveform import DimensionlessWaveform\n\n# Waveform parameters\nmass1 = mass2 = 25\ndistance = 10\nf_lower = 20\ninclination, coa_phase = 0, 0\nkwargs = {\n    \"mass1\": mass1,\n    \"mass2\": mass2,\n    \"inclination\": inclination,\n    \"coa_phase\": coa_phase,\n    \"delta_t\": 1.0 / 4096,\n    \"f_lower\": f_lower,\n    \"f_ref\": 25,\n    \"distance\": distance,\n}\n\nphenom = Waveform.from_model(\"IMRPhenomD\", [(2, 2)], **kwargs)\n\n# Load simulation and scale to SI units\nsim = DimensionlessWaveform.from_sim(\"SXS:BBH:1155\")\nsim10sm = sim.to_Waveform(f_lower, mass1 + mass2, distance, inclination, coa_phase)\n\n# Plot strain\nplt.plot(phenom.time, phenom[2, 2], label=\"IMRPhenomD\")\nplt.plot(sim10sm.time, sim10sm[2, 2], label=\"SXS:BBH:1155\")\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Strain (m)\")\nplt.legend()\nplt.show()\n\n</code></pre>"},{"location":"api/basewaveform/","title":"BaseWaveform","text":"<p>Base for all Waveform objects, containing all core attributes and methods.</p> <p>This class handles generic waveform functionality such as time alignment, strain recombination, and metadata normalization. It is not meant to be instantiated directly but serves as the foundation for higher-level classes like <code>Waveform</code> and <code>DimensionlessWaveform</code>.</p> <p>Attributes:</p> Name Type Description <code>strain</code> <code>ndarray</code> <p>Stacked complex strain data for each mode.</p> <code>time</code> <code>ndarray</code> <p>Time array corresponding to the waveform.</p> <code>metadata</code> <code>Metadata</code> <p>Object storing waveform parameters and provenance.</p> Source code in <code>src/qcextender/basewaveform.py</code> <pre><code>class BaseWaveform:\n    \"\"\"Base for all Waveform objects, containing all core attributes and methods.\n\n    This class handles generic waveform functionality such as time alignment, strain recombination, and metadata normalization. It is not meant to be\n    instantiated directly but serves as the foundation for higher-level classes like `Waveform` and `DimensionlessWaveform`.\n\n    Attributes:\n        strain (np.ndarray): Stacked complex strain data for each mode.\n        time (np.ndarray): Time array corresponding to the waveform.\n        metadata (Metadata): Object storing waveform parameters and provenance.\n    \"\"\"\n\n    def __init__(\n        self, strain: np.ndarray, time: np.ndarray, metadata: Metadata\n    ) -&gt; None:\n        \"\"\"Initializes class containing waveform data.\n\n        Args:\n            strain (np.ndarray): Stacked array of multi-modal wave strains.\n            time (np.ndarray): Time array, should be the same length as component strain arrays.\n            metadata (Metadata): Metadata belonging to the generated or requested waveform.\n        \"\"\"\n        self.strain = strain\n        self.time = time\n        self.metadata = metadata\n\n    def __getitem__(self, mode: tuple[int, int]) -&gt; np.ndarray:\n        \"\"\"Returns the single-mode wave strain corresponding to (l, m).\n\n        Args:\n            mode (tuple[int, int]): Spherical harmonics decomposed strain mode.\n\n        Raises:\n            ValueError: If this waveform object does not contain the requested mode.\n\n        Returns:\n            np.ndarray: The complex strain for the requested mode.\n        \"\"\"\n        modes = self.metadata[\"modes\"]\n        try:\n            index = modes.index((mode[0], abs(mode[1])))\n        except ValueError:\n            raise ValueError(f\"Mode {mode} not found in this waveform.\")\n\n        # For negative m, return the conjugate mode with parity correction\n        if mode[1] &lt; 0:\n            return (-1) ** mode[0] * np.conj(self.strain[index])\n        return self.strain[index]\n\n    @staticmethod\n    def _align(strain: np.ndarray, time: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Aligns waveform such that the dominant order peak is at t=0.\n\n        Args:\n            strain (np.ndarray): Waveform strain data.\n            time (np.ndarray): Time array prior to realigning.\n\n        Returns:\n            np.ndarray: New time array aligned to the maximum amplitude.\n        \"\"\"\n        time -= time[np.argmax(np.abs(strain))] + time[0]\n        return time\n\n    @staticmethod\n    def _kwargs_to_metadata(kwargs: dict[str, type]) -&gt; Metadata:\n        \"\"\"Converts simulation metadata or kwargs into a uniform Metadata object.\n\n        Args:\n            kwargs (dict[str, type]): Keyword arguments used to generate waveform or SXS metadata.\n\n        Returns:\n            Metadata: Unified object encoding all important metadata fields.\n        \"\"\"\n        meta_fields = {f.name for f in fields(Metadata)}\n\n        aliases = {\n            \"reference_dimensionless_spin1\": \"spin1\",\n            \"reference_dimensionless_spin2\": \"spin2\",\n            \"reference_eccentricity\": \"eccentricity\",\n        }\n\n        fixed_kwargs = {}\n        for k, v in kwargs.items():\n            k = aliases.get(k, k)\n            if k in meta_fields:\n                if k in (\"spin1\", \"spin2\") and v is not None:\n                    fixed_kwargs[k] = tuple(v)  # normalize to tuple\n                else:\n                    fixed_kwargs[k] = v\n\n        return Metadata(**fixed_kwargs)\n\n    def recombine_strain(self, time: np.ndarray | None = None) -&gt; np.ndarray:\n        \"\"\"Recombines individual (l, m) strain modes into a total observed strain.\n\n        Args:\n            time (np.ndarray | None, optional): Optional new time array for resampling via spline interpolation.\n                If None, uses the waveform's native time array.\n\n        Returns:\n            np.ndarray: Complex strain representing the full waveform at the given inclination and phase.\n        \"\"\"\n        strain = 0\n        for mode in self.metadata.modes:\n            if time is not None:\n                single_mode = make_interp_spline(self.time, self[mode])(time)\n                single_minus_mode = make_interp_spline(\n                    self.time, self[mode[0], -mode[1]]\n                )(time)\n            else:\n                single_mode = self[mode]\n                single_minus_mode = self[mode[0], -mode[1]]\n\n            strain += single_mode * spherical_harmonics(\n                mode[0], mode[1], self.metadata.inclination, self.metadata.coa_phase\n            ) + single_minus_mode * spherical_harmonics(\n                mode[0],\n                -mode[1],\n                self.metadata.inclination,\n                self.metadata.coa_phase,\n            )\n        return strain\n\n    def amp(self, mode: tuple[int, int] = (2, 2)) -&gt; np.ndarray:\n        \"\"\"Returns the amplitude of the specified mode.\n\n        Args:\n            mode (tuple[int, int], optional): Mode for which the amplitude is requested. Defaults to (2, 2).\n\n        Returns:\n            np.ndarray: The amplitude of the mode.\n        \"\"\"\n        return amp(self[mode])\n\n    def phase(self, mode: tuple[int, int] = (2, 2)) -&gt; np.ndarray:\n        \"\"\"Returns the phase of the specified mode.\n\n        Args:\n            mode (tuple[int, int], optional): Mode for which the phase is requested. Defaults to (2, 2).\n\n        Returns:\n            np.ndarray: The phase of the mode.\n        \"\"\"\n        return phase(self[mode])\n\n    def omega(self, mode: tuple[int, int] = (2, 2)) -&gt; np.ndarray:\n        \"\"\"Returns the angular frequency (omega) of the specified mode.\n\n        Args:\n            mode (tuple[int, int], optional): Mode for which the omega is requested. Defaults to (2, 2).\n\n        Returns:\n            np.ndarray: The instantaneous angular frequency of the mode.\n        \"\"\"\n        return omega(self[mode], self.time)\n</code></pre>"},{"location":"api/basewaveform/#qcextender.basewaveform.BaseWaveform.__getitem__","title":"<code>__getitem__(mode)</code>","text":"<p>Returns the single-mode wave strain corresponding to (l, m).</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>tuple[int, int]</code> <p>Spherical harmonics decomposed strain mode.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If this waveform object does not contain the requested mode.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The complex strain for the requested mode.</p> Source code in <code>src/qcextender/basewaveform.py</code> <pre><code>def __getitem__(self, mode: tuple[int, int]) -&gt; np.ndarray:\n    \"\"\"Returns the single-mode wave strain corresponding to (l, m).\n\n    Args:\n        mode (tuple[int, int]): Spherical harmonics decomposed strain mode.\n\n    Raises:\n        ValueError: If this waveform object does not contain the requested mode.\n\n    Returns:\n        np.ndarray: The complex strain for the requested mode.\n    \"\"\"\n    modes = self.metadata[\"modes\"]\n    try:\n        index = modes.index((mode[0], abs(mode[1])))\n    except ValueError:\n        raise ValueError(f\"Mode {mode} not found in this waveform.\")\n\n    # For negative m, return the conjugate mode with parity correction\n    if mode[1] &lt; 0:\n        return (-1) ** mode[0] * np.conj(self.strain[index])\n    return self.strain[index]\n</code></pre>"},{"location":"api/basewaveform/#qcextender.basewaveform.BaseWaveform.__init__","title":"<code>__init__(strain, time, metadata)</code>","text":"<p>Initializes class containing waveform data.</p> <p>Parameters:</p> Name Type Description Default <code>strain</code> <code>ndarray</code> <p>Stacked array of multi-modal wave strains.</p> required <code>time</code> <code>ndarray</code> <p>Time array, should be the same length as component strain arrays.</p> required <code>metadata</code> <code>Metadata</code> <p>Metadata belonging to the generated or requested waveform.</p> required Source code in <code>src/qcextender/basewaveform.py</code> <pre><code>def __init__(\n    self, strain: np.ndarray, time: np.ndarray, metadata: Metadata\n) -&gt; None:\n    \"\"\"Initializes class containing waveform data.\n\n    Args:\n        strain (np.ndarray): Stacked array of multi-modal wave strains.\n        time (np.ndarray): Time array, should be the same length as component strain arrays.\n        metadata (Metadata): Metadata belonging to the generated or requested waveform.\n    \"\"\"\n    self.strain = strain\n    self.time = time\n    self.metadata = metadata\n</code></pre>"},{"location":"api/basewaveform/#qcextender.basewaveform.BaseWaveform.amp","title":"<code>amp(mode=(2, 2))</code>","text":"<p>Returns the amplitude of the specified mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>tuple[int, int]</code> <p>Mode for which the amplitude is requested. Defaults to (2, 2).</p> <code>(2, 2)</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The amplitude of the mode.</p> Source code in <code>src/qcextender/basewaveform.py</code> <pre><code>def amp(self, mode: tuple[int, int] = (2, 2)) -&gt; np.ndarray:\n    \"\"\"Returns the amplitude of the specified mode.\n\n    Args:\n        mode (tuple[int, int], optional): Mode for which the amplitude is requested. Defaults to (2, 2).\n\n    Returns:\n        np.ndarray: The amplitude of the mode.\n    \"\"\"\n    return amp(self[mode])\n</code></pre>"},{"location":"api/basewaveform/#qcextender.basewaveform.BaseWaveform.omega","title":"<code>omega(mode=(2, 2))</code>","text":"<p>Returns the angular frequency (omega) of the specified mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>tuple[int, int]</code> <p>Mode for which the omega is requested. Defaults to (2, 2).</p> <code>(2, 2)</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The instantaneous angular frequency of the mode.</p> Source code in <code>src/qcextender/basewaveform.py</code> <pre><code>def omega(self, mode: tuple[int, int] = (2, 2)) -&gt; np.ndarray:\n    \"\"\"Returns the angular frequency (omega) of the specified mode.\n\n    Args:\n        mode (tuple[int, int], optional): Mode for which the omega is requested. Defaults to (2, 2).\n\n    Returns:\n        np.ndarray: The instantaneous angular frequency of the mode.\n    \"\"\"\n    return omega(self[mode], self.time)\n</code></pre>"},{"location":"api/basewaveform/#qcextender.basewaveform.BaseWaveform.phase","title":"<code>phase(mode=(2, 2))</code>","text":"<p>Returns the phase of the specified mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>tuple[int, int]</code> <p>Mode for which the phase is requested. Defaults to (2, 2).</p> <code>(2, 2)</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The phase of the mode.</p> Source code in <code>src/qcextender/basewaveform.py</code> <pre><code>def phase(self, mode: tuple[int, int] = (2, 2)) -&gt; np.ndarray:\n    \"\"\"Returns the phase of the specified mode.\n\n    Args:\n        mode (tuple[int, int], optional): Mode for which the phase is requested. Defaults to (2, 2).\n\n    Returns:\n        np.ndarray: The phase of the mode.\n    \"\"\"\n    return phase(self[mode])\n</code></pre>"},{"location":"api/basewaveform/#qcextender.basewaveform.BaseWaveform.recombine_strain","title":"<code>recombine_strain(time=None)</code>","text":"<p>Recombines individual (l, m) strain modes into a total observed strain.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>ndarray | None</code> <p>Optional new time array for resampling via spline interpolation. If None, uses the waveform's native time array.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Complex strain representing the full waveform at the given inclination and phase.</p> Source code in <code>src/qcextender/basewaveform.py</code> <pre><code>def recombine_strain(self, time: np.ndarray | None = None) -&gt; np.ndarray:\n    \"\"\"Recombines individual (l, m) strain modes into a total observed strain.\n\n    Args:\n        time (np.ndarray | None, optional): Optional new time array for resampling via spline interpolation.\n            If None, uses the waveform's native time array.\n\n    Returns:\n        np.ndarray: Complex strain representing the full waveform at the given inclination and phase.\n    \"\"\"\n    strain = 0\n    for mode in self.metadata.modes:\n        if time is not None:\n            single_mode = make_interp_spline(self.time, self[mode])(time)\n            single_minus_mode = make_interp_spline(\n                self.time, self[mode[0], -mode[1]]\n            )(time)\n        else:\n            single_mode = self[mode]\n            single_minus_mode = self[mode[0], -mode[1]]\n\n        strain += single_mode * spherical_harmonics(\n            mode[0], mode[1], self.metadata.inclination, self.metadata.coa_phase\n        ) + single_minus_mode * spherical_harmonics(\n            mode[0],\n            -mode[1],\n            self.metadata.inclination,\n            self.metadata.coa_phase,\n        )\n    return strain\n</code></pre>"},{"location":"api/dimensionlesswaveform/","title":"DimensionlessWaveform","text":"<p>               Bases: <code>BaseWaveform</code></p> <p>Represents a dimensionless gravitational waveform from an NR simulation.</p> <p>The waveform contains multiple spherical harmonic modes and associated simulation metadata. It can be converted into a dimensional <code>Waveform</code> object using the <code>to_Waveform</code> method.</p> <p>Attributes:</p> Name Type Description <code>strain</code> <code>ndarray</code> <p>Stacked complex strain data for each mode.</p> <code>time</code> <code>ndarray</code> <p>Time array corresponding to the waveform.</p> <code>metadata</code> <code>Metadata</code> <p>Object storing waveform parameters and provenance.</p> Source code in <code>src/qcextender/dimensionlesswaveform.py</code> <pre><code>class DimensionlessWaveform(BaseWaveform):\n    \"\"\"Represents a dimensionless gravitational waveform from an NR simulation.\n\n    The waveform contains multiple spherical harmonic modes and associated simulation metadata. It can be converted into a dimensional\n    `Waveform` object using the `to_Waveform` method.\n\n    Attributes:\n        strain (np.ndarray): Stacked complex strain data for each mode.\n        time (np.ndarray): Time array corresponding to the waveform.\n        metadata (Metadata): Object storing waveform parameters and provenance.\n    \"\"\"\n\n    def __init__(\n        self, strain: np.ndarray, time: np.ndarray, metadata: Metadata\n    ) -&gt; None:\n        \"\"\"Initialize a dimensionless waveform.\n\n        Args:\n            strain (np.ndarray): Stacked array of complex strain modes.\n            time (np.ndarray): Time array (dimensionless units), same length as strain arrays.\n            metadata (Metadata): Simulation metadata describing the waveform.\n        \"\"\"\n        super().__init__(strain, time, metadata)\n\n    @classmethod\n    def from_sim(cls, sim_id: str, modes: list[tuple[int, int]] = [(2, 2)]) -&gt; Self:\n        \"\"\"Load a dimensionless waveform from an SXS simulation.\n\n        Args:\n            sim_id (str): Simulation identifier in the SXS catalog (e.g., \"SXS:BBH:1155\").\n            modes (list[tuple[int, int]]): List of (l, m) modes to include. Defaults to [(2, 2)].\n\n        Raises:\n            ValueError: If a requested mode is not available in the simulation.\n\n        Returns:\n            DimensionlessWaveform: Waveform object containing the requested modes.\n        \"\"\"\n        sim = sxs.load(sim_id, extrapolation=\"Outer\")\n        meta = sim.metadata\n        meta[\"modes\"] = modes\n\n        q = meta[\"initial_mass_ratio\"]\n        if q &lt; 1:\n            q = 1 / q\n\n        dt = np.min(np.diff(sim.h.t))\n        sim = sim.h.interpolate(np.arange(sim.h.t[0], sim.h.t[-1], dt))\n\n        meta.update(\n            library=\"SXS\",\n            simulation_id=sim_id,\n            q=q,\n            modes=list(modes),\n            delta_t=dt,\n            dimensionless=True,\n        )\n\n        single_mode_strain = []\n        for l, m in modes:\n            try:\n                single_mode_strain.append(np.array(sim[:, sim.index(l, m)]))\n            except:\n                raise ValueError(f\"Mode (l={l}, m={m}) not found in this simulation.\")\n\n        time = cls._align(np.array(sim[:, sim.index(l, m)]), sim.t)\n        multi_mode_strain = np.vstack(single_mode_strain)\n        metadata = cls._kwargs_to_metadata(meta)\n        return cls(multi_mode_strain, time, metadata)\n\n    def to_Waveform(\n        self,\n        f_lower: Number,\n        total_mass: Number,\n        distance: Number,\n        inclination: Number = 0,\n        coa_phase: Number = 0,\n    ) -&gt; Waveform:\n        \"\"\"Convert the dimensionless waveform to a dimensional `Waveform`.\n\n        The conversion scales time and strain using physical parameters such as total mass and distance. The resulting waveform is cropped to the longest\n        continuous segment where the orbital frequency exceeds `f_lower`.\n\n        Args:\n            f_lower (Number): Lower frequency bound of the signal [Hz].\n            total_mass (Number): Total mass of the binary [solar masses].\n            distance (Number): Luminosity distance to the source [megaparsecs].\n            inclination (Number, optional): Inclination angle of the system [radians]. Defaults to 0.\n            coa_phase (Number, optional): Coalescence phase [radians]. Defaults to 0.\n\n        Raises:\n            ValueError: If no part of the waveform remains above `f_lower`.\n\n        Returns:\n            Waveform: Dimensional waveform object with physical units.\n        \"\"\"\n        time = tM_to_tSI(self.time, total_mass)\n        metadata = self.metadata.copy()\n        newmetadata = metadata.to_dimensional(\n            f_lower, total_mass, distance, inclination, coa_phase\n        )\n\n        single_mode_strains = []\n        for mode in self.metadata.modes:\n            singlemode = mM_to_mSI(self[mode], total_mass, distance)\n\n            omega = np.gradient(-np.unwrap(np.angle(singlemode)), time)\n            arg = np.abs(singlemode)\n            phase = np.unwrap(np.angle(singlemode))\n\n            # Takes longest stretch where wave is above f_lower, assumes wave above f_lower is longer than noise above f_lower\n            indices = np.where(omega &gt; 2 * np.pi * f_lower)[0]\n            if len(indices) == 0:\n                mask = np.array([], dtype=int)\n            else:\n                breaks = np.where(np.diff(indices) != 1)[0] + 1\n                segments = np.split(indices, breaks)\n\n                mask = max(segments, key=len)\n\n            if mask.size == 0:\n                raise ValueError(\n                    \"None of the wave remains above f_lower with the chosen parameters.\"\n                )\n\n            single_mode_strains.append(arg[mask] * np.exp(1j * phase[mask]))\n\n        strain = np.vstack(single_mode_strains)\n        return Waveform(strain, time[mask], newmetadata)\n</code></pre>"},{"location":"api/dimensionlesswaveform/#qcextender.dimensionlesswaveform.DimensionlessWaveform.__init__","title":"<code>__init__(strain, time, metadata)</code>","text":"<p>Initialize a dimensionless waveform.</p> <p>Parameters:</p> Name Type Description Default <code>strain</code> <code>ndarray</code> <p>Stacked array of complex strain modes.</p> required <code>time</code> <code>ndarray</code> <p>Time array (dimensionless units), same length as strain arrays.</p> required <code>metadata</code> <code>Metadata</code> <p>Simulation metadata describing the waveform.</p> required Source code in <code>src/qcextender/dimensionlesswaveform.py</code> <pre><code>def __init__(\n    self, strain: np.ndarray, time: np.ndarray, metadata: Metadata\n) -&gt; None:\n    \"\"\"Initialize a dimensionless waveform.\n\n    Args:\n        strain (np.ndarray): Stacked array of complex strain modes.\n        time (np.ndarray): Time array (dimensionless units), same length as strain arrays.\n        metadata (Metadata): Simulation metadata describing the waveform.\n    \"\"\"\n    super().__init__(strain, time, metadata)\n</code></pre>"},{"location":"api/dimensionlesswaveform/#qcextender.dimensionlesswaveform.DimensionlessWaveform.from_sim","title":"<code>from_sim(sim_id, modes=[(2, 2)])</code>  <code>classmethod</code>","text":"<p>Load a dimensionless waveform from an SXS simulation.</p> <p>Parameters:</p> Name Type Description Default <code>sim_id</code> <code>str</code> <p>Simulation identifier in the SXS catalog (e.g., \"SXS:BBH:1155\").</p> required <code>modes</code> <code>list[tuple[int, int]]</code> <p>List of (l, m) modes to include. Defaults to [(2, 2)].</p> <code>[(2, 2)]</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a requested mode is not available in the simulation.</p> <p>Returns:</p> Name Type Description <code>DimensionlessWaveform</code> <code>Self</code> <p>Waveform object containing the requested modes.</p> Source code in <code>src/qcextender/dimensionlesswaveform.py</code> <pre><code>@classmethod\ndef from_sim(cls, sim_id: str, modes: list[tuple[int, int]] = [(2, 2)]) -&gt; Self:\n    \"\"\"Load a dimensionless waveform from an SXS simulation.\n\n    Args:\n        sim_id (str): Simulation identifier in the SXS catalog (e.g., \"SXS:BBH:1155\").\n        modes (list[tuple[int, int]]): List of (l, m) modes to include. Defaults to [(2, 2)].\n\n    Raises:\n        ValueError: If a requested mode is not available in the simulation.\n\n    Returns:\n        DimensionlessWaveform: Waveform object containing the requested modes.\n    \"\"\"\n    sim = sxs.load(sim_id, extrapolation=\"Outer\")\n    meta = sim.metadata\n    meta[\"modes\"] = modes\n\n    q = meta[\"initial_mass_ratio\"]\n    if q &lt; 1:\n        q = 1 / q\n\n    dt = np.min(np.diff(sim.h.t))\n    sim = sim.h.interpolate(np.arange(sim.h.t[0], sim.h.t[-1], dt))\n\n    meta.update(\n        library=\"SXS\",\n        simulation_id=sim_id,\n        q=q,\n        modes=list(modes),\n        delta_t=dt,\n        dimensionless=True,\n    )\n\n    single_mode_strain = []\n    for l, m in modes:\n        try:\n            single_mode_strain.append(np.array(sim[:, sim.index(l, m)]))\n        except:\n            raise ValueError(f\"Mode (l={l}, m={m}) not found in this simulation.\")\n\n    time = cls._align(np.array(sim[:, sim.index(l, m)]), sim.t)\n    multi_mode_strain = np.vstack(single_mode_strain)\n    metadata = cls._kwargs_to_metadata(meta)\n    return cls(multi_mode_strain, time, metadata)\n</code></pre>"},{"location":"api/dimensionlesswaveform/#qcextender.dimensionlesswaveform.DimensionlessWaveform.to_Waveform","title":"<code>to_Waveform(f_lower, total_mass, distance, inclination=0, coa_phase=0)</code>","text":"<p>Convert the dimensionless waveform to a dimensional <code>Waveform</code>.</p> <p>The conversion scales time and strain using physical parameters such as total mass and distance. The resulting waveform is cropped to the longest continuous segment where the orbital frequency exceeds <code>f_lower</code>.</p> <p>Parameters:</p> Name Type Description Default <code>f_lower</code> <code>Number</code> <p>Lower frequency bound of the signal [Hz].</p> required <code>total_mass</code> <code>Number</code> <p>Total mass of the binary [solar masses].</p> required <code>distance</code> <code>Number</code> <p>Luminosity distance to the source [megaparsecs].</p> required <code>inclination</code> <code>Number</code> <p>Inclination angle of the system [radians]. Defaults to 0.</p> <code>0</code> <code>coa_phase</code> <code>Number</code> <p>Coalescence phase [radians]. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no part of the waveform remains above <code>f_lower</code>.</p> <p>Returns:</p> Name Type Description <code>Waveform</code> <code>Waveform</code> <p>Dimensional waveform object with physical units.</p> Source code in <code>src/qcextender/dimensionlesswaveform.py</code> <pre><code>def to_Waveform(\n    self,\n    f_lower: Number,\n    total_mass: Number,\n    distance: Number,\n    inclination: Number = 0,\n    coa_phase: Number = 0,\n) -&gt; Waveform:\n    \"\"\"Convert the dimensionless waveform to a dimensional `Waveform`.\n\n    The conversion scales time and strain using physical parameters such as total mass and distance. The resulting waveform is cropped to the longest\n    continuous segment where the orbital frequency exceeds `f_lower`.\n\n    Args:\n        f_lower (Number): Lower frequency bound of the signal [Hz].\n        total_mass (Number): Total mass of the binary [solar masses].\n        distance (Number): Luminosity distance to the source [megaparsecs].\n        inclination (Number, optional): Inclination angle of the system [radians]. Defaults to 0.\n        coa_phase (Number, optional): Coalescence phase [radians]. Defaults to 0.\n\n    Raises:\n        ValueError: If no part of the waveform remains above `f_lower`.\n\n    Returns:\n        Waveform: Dimensional waveform object with physical units.\n    \"\"\"\n    time = tM_to_tSI(self.time, total_mass)\n    metadata = self.metadata.copy()\n    newmetadata = metadata.to_dimensional(\n        f_lower, total_mass, distance, inclination, coa_phase\n    )\n\n    single_mode_strains = []\n    for mode in self.metadata.modes:\n        singlemode = mM_to_mSI(self[mode], total_mass, distance)\n\n        omega = np.gradient(-np.unwrap(np.angle(singlemode)), time)\n        arg = np.abs(singlemode)\n        phase = np.unwrap(np.angle(singlemode))\n\n        # Takes longest stretch where wave is above f_lower, assumes wave above f_lower is longer than noise above f_lower\n        indices = np.where(omega &gt; 2 * np.pi * f_lower)[0]\n        if len(indices) == 0:\n            mask = np.array([], dtype=int)\n        else:\n            breaks = np.where(np.diff(indices) != 1)[0] + 1\n            segments = np.split(indices, breaks)\n\n            mask = max(segments, key=len)\n\n        if mask.size == 0:\n            raise ValueError(\n                \"None of the wave remains above f_lower with the chosen parameters.\"\n            )\n\n        single_mode_strains.append(arg[mask] * np.exp(1j * phase[mask]))\n\n    strain = np.vstack(single_mode_strains)\n    return Waveform(strain, time[mask], newmetadata)\n</code></pre>"},{"location":"api/functions/","title":"Functions","text":""},{"location":"api/functions/#qcextender.functions","title":"<code>qcextender.functions</code>","text":"<p>Core mathematical functions for gravitational waveform analysis.</p> <p>Provides basic utilities to extract amplitude, phase, and instantaneous frequency from complex gravitational-wave strains. These functions are lightweight wrappers around NumPy operations and are intended for use throughout the <code>qcextender</code> package.</p> Example <p>from qcextender import functions as fn strain = np.exp(1j * np.linspace(0, 4*np.pi, 1000)) fn.amp(strain)[0], fn.phase(strain)[-1] (1.0, 12.566370614359172)</p>"},{"location":"api/functions/#qcextender.functions.spherical_harmonics","title":"<code>spherical_harmonics(l, m, iota, phi, s=-2)</code>","text":"<p>Calculates the spin-weighted spherical harmonics. Code adapted from the Spheroidal package.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>int</code> <p>Degree of the spherical harmonics.</p> required <code>m</code> <code>int</code> <p>Integer order of the spherical harmonics.</p> required <code>iota</code> <code>Number</code> <p>The inclination angle in radians.</p> required <code>phi</code> <code>Number</code> <p>The phase of coalescence in radians.</p> required <code>s</code> <code>Number</code> <p>Int or half-integer spin-weight. Defaults to -2.</p> <code>-2</code> <p>Returns:</p> Name Type Description <code>complex</code> <code>complex</code> <p>The spin-weighted spherical harmonics of mode (l, m)</p> Source code in <code>src/qcextender/functions.py</code> <pre><code>def spherical_harmonics(\n    l: int, m: int, iota: Number, phi: Number, s: Number = -2\n) -&gt; complex:\n    \"\"\"Calculates the spin-weighted spherical harmonics. Code adapted from the Spheroidal package.\n\n    Args:\n        l (int): Degree of the spherical harmonics.\n        m (int): Integer order of the spherical harmonics.\n        iota (Number): The inclination angle in radians.\n        phi (Number): The phase of coalescence in radians.\n        s (Number, optional): Int or half-integer spin-weight. Defaults to -2.\n\n    Returns:\n        complex: The spin-weighted spherical harmonics of mode (l, m)\n    \"\"\"\n    prefactor = (-1.0) ** (l + m - s + 0j)\n    prefactor *= np.sqrt(\n        factorial(l + m)\n        * factorial(l - m)\n        * (2 * l + 1)\n        / (4 * np.pi * factorial(l + s) * factorial(l - s))\n    )\n\n    alternating_sum = 0\n    for r in range(int(max(m - s, 0)), int(min(l - s, l + m) + 1)):\n        alternating_sum += (\n            (-1) ** r\n            * binom(l - s, r)\n            * binom(l + s, r + s - m)\n            * np.sin(iota / 2) ** (2 * l - 2 * r - s + m)\n            * np.cos(iota / 2) ** (2 * r + s - m)\n        )\n\n    return prefactor * np.exp(1j * m * phi) * alternating_sum\n</code></pre>"},{"location":"api/functions/#qcextender.functions.amp","title":"<code>amp(strain)</code>","text":"<p>Compute the amplitude of a complex strain signal.</p> <p>Parameters:</p> Name Type Description Default <code>strain</code> <code>ndarray</code> <p>Complex gravitational-wave strain.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Amplitude |h(t)|.</p> Source code in <code>src/qcextender/functions.py</code> <pre><code>def amp(strain: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Compute the amplitude of a complex strain signal.\n\n    Args:\n        strain (np.ndarray): Complex gravitational-wave strain.\n\n    Returns:\n        np.ndarray: Amplitude |h(t)|.\n    \"\"\"\n    return np.abs(strain)\n</code></pre>"},{"location":"api/functions/#qcextender.functions.phase","title":"<code>phase(strain)</code>","text":"<p>Compute the unwrapped phase of a complex strain signal.</p> <p>Parameters:</p> Name Type Description Default <code>strain</code> <code>ndarray</code> <p>Complex gravitational-wave strain.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Unwrapped phase \u03c6(t) in radians.</p> Source code in <code>src/qcextender/functions.py</code> <pre><code>def phase(strain: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Compute the unwrapped phase of a complex strain signal.\n\n    Args:\n        strain (np.ndarray): Complex gravitational-wave strain.\n\n    Returns:\n        np.ndarray: Unwrapped phase \u03c6(t) in radians.\n    \"\"\"\n    return np.unwrap(np.angle(strain))\n</code></pre>"},{"location":"api/functions/#qcextender.functions.omega","title":"<code>omega(strain, time)</code>","text":"<p>Compute the instantaneous angular frequency of a strain signal.</p> <p>Calculated as the time derivative of the unwrapped phase.</p> <p>Parameters:</p> Name Type Description Default <code>strain</code> <code>ndarray</code> <p>Complex gravitational-wave strain.</p> required <code>time</code> <code>ndarray</code> <p>Time array corresponding to the strain samples [s].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Instantaneous angular frequency \u03c9(t) [rad/s].</p> Source code in <code>src/qcextender/functions.py</code> <pre><code>def omega(strain: np.ndarray, time: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Compute the instantaneous angular frequency of a strain signal.\n\n    Calculated as the time derivative of the unwrapped phase.\n\n    Args:\n        strain (np.ndarray): Complex gravitational-wave strain.\n        time (np.ndarray): Time array corresponding to the strain samples [s].\n\n    Returns:\n        np.ndarray: Instantaneous angular frequency \u03c9(t) [rad/s].\n    \"\"\"\n    return np.gradient(-np.unwrap(np.angle(strain)), time)\n</code></pre>"},{"location":"api/metadata/","title":"Metadata","text":"<p>Unified container for waveform metadata or generation parameters.</p> <p>This class ensures consistent handling of waveform metadata between simulation-based (dimensionless) and physical (dimensional) waveforms.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If initialized incorrectly due to missing required dimensional parameters.</p> Source code in <code>src/qcextender/metadata.py</code> <pre><code>@dataclass\nclass Metadata:\n    \"\"\"Unified container for waveform metadata or generation parameters.\n\n    This class ensures consistent handling of waveform metadata between\n    simulation-based (dimensionless) and physical (dimensional) waveforms.\n\n    Raises:\n        ValueError: If initialized incorrectly due to missing required dimensional parameters.\n    \"\"\"\n\n    # Core properties\n    library: str\n    q: float\n    delta_t: float\n\n    # Model/simulation identification\n    approximant: Optional[str] = None\n    simulation_id: Optional[str] = None\n\n    # Physical parameters\n    total_mass: Optional[float] = None\n    distance: Optional[float] = None\n\n    # Spin and orbital parameters\n    spin1: tuple[float, float, float] = (0, 0, 0)\n    spin2: tuple[float, float, float] = (0, 0, 0)\n    eccentricity: float = 0\n    inclination: float = 0\n    coa_phase: float = 0\n\n    # Frequency-related parameters\n    f_lower: Optional[float] = None\n    f_ref: Optional[float] = None\n\n    # Mode and domain information\n    modes: Iterable[tuple[int, int]] = field(default_factory=list)\n    dimensionless: bool = False\n    aligned_to_peak: bool = True\n\n    # Preferred order for __repr__\n    _REPR_ORDER = [\n        \"library\",\n        \"approximant\",\n        \"simulation_id\",\n        \"q\",\n        \"total_mass\",\n        \"distance\",\n        \"spin1\",\n        \"spin2\",\n        \"eccentricity\",\n        \"inclination\",\n        \"coa_phase\",\n        \"f_lower\",\n        \"f_ref\",\n        \"delta_t\",\n        \"modes\",\n        \"dimensionless\",\n        \"aligned_to_peak\",\n    ]\n\n    def __getitem__(self, key: str) -&gt; type:\n        \"\"\"Access a metadata attribute using dict-like indexing.\n\n        Args:\n            key (str): Name of the requested item.\n\n        Returns:\n            type: Value of the key.\n        \"\"\"\n        return getattr(self, key)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation of the metadata.\n\n        Only includes assigned values in a fixed order for readability.\n\n        Returns:\n            str: Formatted string representation of the Metadata object.\n        \"\"\"\n        parts = []\n        for name in self._REPR_ORDER:\n            val = getattr(self, name, None)\n            if val is not None:\n                parts.append(f\"{name}={val}\")\n        return f\"Metadata({', '.join(parts)})\"\n\n    def __post_init__(self):\n        \"\"\"Post-initialization validation.\n\n        Ensures correct consistency between dimensional and dimensionless metadata.\n\n        Raises:\n            ValueError: If required parameters are missing for dimensional metadata.\n        \"\"\"\n        if self.dimensionless:\n            self.total_mass = None\n            self.distance = None\n        else:\n            if self.total_mass is None or self.distance is None:\n                raise ValueError(\n                    \"Both total_mass and distance must be defined for dimensional waveforms.\"\n                )\n\n    def __copy__(self) -&gt; Self:\n        \"\"\"Creates a shallow copy of this Metadata object.\n\n        Returns:\n            Self: Shallow copy of the Metadata instance.\n        \"\"\"\n        cls = self.__class__\n        copied = cls(\n            **{\n                f.name: getattr(self, f.name)\n                for f in self.__dataclass_fields__.values()\n            }\n        )\n\n        # Copy mutable attributes explicitly\n        if isinstance(self.modes, list):\n            copied.modes = self.modes.copy()\n\n        return copied\n\n    def copy(self) -&gt; Self:\n        \"\"\"Alias for __copy__ to follow common Python convention.\n\n        Returns:\n            Self: Shallow copy of Metadata object.\n        \"\"\"\n        return self.__copy__()\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Returns metadata as a dictionary.\n\n        Returns:\n            dict: Dictionary representation of this Metadata object.\n        \"\"\"\n        return asdict(self)\n\n    def to_dimensional(\n        self,\n        f_lower: Number,\n        total_mass: Number,\n        distance: Number,\n        inclination: Number,\n        coa_phase: Number,\n    ) -&gt; Self:\n        \"\"\"Converts this dimensionless Metadata instance into a dimensional one.\n\n        This method updates frequency, mass, distance, and angle parameters, converts delta_t from M-units to SI seconds, and toggles the\n        `dimensionless` flag to False. Copy metadata first to avoid overwriting.\n\n        Args:\n            f_lower (Number): Lower frequency bound of the waveform.\n            total_mass (Number): Total mass of the system in solar masses.\n            distance (Number): Distance to the source in Mpc.\n            inclination (Number): Inclination angle of the system.\n            coa_phase (Number): Coalescence phase.\n\n        Returns:\n            Self: The same Metadata instance, modified in-place and dimensionalized.\n        \"\"\"\n        self.f_lower = f_lower\n        self.total_mass = total_mass\n        self.distance = distance\n        self.inclination = inclination\n        self.coa_phase = coa_phase\n        self.delta_t = tM_to_tSI(self.delta_t, total_mass)\n        self.dimensionless = False\n        return self\n</code></pre>"},{"location":"api/metadata/#qcextender.metadata.Metadata.__copy__","title":"<code>__copy__()</code>","text":"<p>Creates a shallow copy of this Metadata object.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Shallow copy of the Metadata instance.</p> Source code in <code>src/qcextender/metadata.py</code> <pre><code>def __copy__(self) -&gt; Self:\n    \"\"\"Creates a shallow copy of this Metadata object.\n\n    Returns:\n        Self: Shallow copy of the Metadata instance.\n    \"\"\"\n    cls = self.__class__\n    copied = cls(\n        **{\n            f.name: getattr(self, f.name)\n            for f in self.__dataclass_fields__.values()\n        }\n    )\n\n    # Copy mutable attributes explicitly\n    if isinstance(self.modes, list):\n        copied.modes = self.modes.copy()\n\n    return copied\n</code></pre>"},{"location":"api/metadata/#qcextender.metadata.Metadata.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Access a metadata attribute using dict-like indexing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Name of the requested item.</p> required <p>Returns:</p> Name Type Description <code>type</code> <code>type</code> <p>Value of the key.</p> Source code in <code>src/qcextender/metadata.py</code> <pre><code>def __getitem__(self, key: str) -&gt; type:\n    \"\"\"Access a metadata attribute using dict-like indexing.\n\n    Args:\n        key (str): Name of the requested item.\n\n    Returns:\n        type: Value of the key.\n    \"\"\"\n    return getattr(self, key)\n</code></pre>"},{"location":"api/metadata/#qcextender.metadata.Metadata.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post-initialization validation.</p> <p>Ensures correct consistency between dimensional and dimensionless metadata.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required parameters are missing for dimensional metadata.</p> Source code in <code>src/qcextender/metadata.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Post-initialization validation.\n\n    Ensures correct consistency between dimensional and dimensionless metadata.\n\n    Raises:\n        ValueError: If required parameters are missing for dimensional metadata.\n    \"\"\"\n    if self.dimensionless:\n        self.total_mass = None\n        self.distance = None\n    else:\n        if self.total_mass is None or self.distance is None:\n            raise ValueError(\n                \"Both total_mass and distance must be defined for dimensional waveforms.\"\n            )\n</code></pre>"},{"location":"api/metadata/#qcextender.metadata.Metadata.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of the metadata.</p> <p>Only includes assigned values in a fixed order for readability.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted string representation of the Metadata object.</p> Source code in <code>src/qcextender/metadata.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of the metadata.\n\n    Only includes assigned values in a fixed order for readability.\n\n    Returns:\n        str: Formatted string representation of the Metadata object.\n    \"\"\"\n    parts = []\n    for name in self._REPR_ORDER:\n        val = getattr(self, name, None)\n        if val is not None:\n            parts.append(f\"{name}={val}\")\n    return f\"Metadata({', '.join(parts)})\"\n</code></pre>"},{"location":"api/metadata/#qcextender.metadata.Metadata.copy","title":"<code>copy()</code>","text":"<p>Alias for copy to follow common Python convention.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Shallow copy of Metadata object.</p> Source code in <code>src/qcextender/metadata.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Alias for __copy__ to follow common Python convention.\n\n    Returns:\n        Self: Shallow copy of Metadata object.\n    \"\"\"\n    return self.__copy__()\n</code></pre>"},{"location":"api/metadata/#qcextender.metadata.Metadata.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns metadata as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary representation of this Metadata object.</p> Source code in <code>src/qcextender/metadata.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Returns metadata as a dictionary.\n\n    Returns:\n        dict: Dictionary representation of this Metadata object.\n    \"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/metadata/#qcextender.metadata.Metadata.to_dimensional","title":"<code>to_dimensional(f_lower, total_mass, distance, inclination, coa_phase)</code>","text":"<p>Converts this dimensionless Metadata instance into a dimensional one.</p> <p>This method updates frequency, mass, distance, and angle parameters, converts delta_t from M-units to SI seconds, and toggles the <code>dimensionless</code> flag to False. Copy metadata first to avoid overwriting.</p> <p>Parameters:</p> Name Type Description Default <code>f_lower</code> <code>Number</code> <p>Lower frequency bound of the waveform.</p> required <code>total_mass</code> <code>Number</code> <p>Total mass of the system in solar masses.</p> required <code>distance</code> <code>Number</code> <p>Distance to the source in Mpc.</p> required <code>inclination</code> <code>Number</code> <p>Inclination angle of the system.</p> required <code>coa_phase</code> <code>Number</code> <p>Coalescence phase.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The same Metadata instance, modified in-place and dimensionalized.</p> Source code in <code>src/qcextender/metadata.py</code> <pre><code>def to_dimensional(\n    self,\n    f_lower: Number,\n    total_mass: Number,\n    distance: Number,\n    inclination: Number,\n    coa_phase: Number,\n) -&gt; Self:\n    \"\"\"Converts this dimensionless Metadata instance into a dimensional one.\n\n    This method updates frequency, mass, distance, and angle parameters, converts delta_t from M-units to SI seconds, and toggles the\n    `dimensionless` flag to False. Copy metadata first to avoid overwriting.\n\n    Args:\n        f_lower (Number): Lower frequency bound of the waveform.\n        total_mass (Number): Total mass of the system in solar masses.\n        distance (Number): Distance to the source in Mpc.\n        inclination (Number): Inclination angle of the system.\n        coa_phase (Number): Coalescence phase.\n\n    Returns:\n        Self: The same Metadata instance, modified in-place and dimensionalized.\n    \"\"\"\n    self.f_lower = f_lower\n    self.total_mass = total_mass\n    self.distance = distance\n    self.inclination = inclination\n    self.coa_phase = coa_phase\n    self.delta_t = tM_to_tSI(self.delta_t, total_mass)\n    self.dimensionless = False\n    return self\n</code></pre>"},{"location":"api/models/","title":"Models","text":""},{"location":"api/models/#qcextender.models","title":"<code>qcextender.models</code>","text":"<p>Waveform generation interface using LALSimulation.</p> <p>Provides a minimal, extendable interface for generating single-mode gravitational waveforms in the time domain.</p> <p>All quantities are returned in SI units. Masses are provided in solar masses, distances in megaparsecs, and spins as dimensionless vectors.</p> Constants <p>PC_SI (float): Parsec in meters. MSUN_SI (float): Solar mass in kilograms.</p> Example <p>from qcextender.waveform_generators import lal_mode t, h = lal_mode( ...     approximant=\"IMRPhenomD\", ...     mass1=30, mass2=25, ...     spin1=[0, 0, 0.5], spin2=[0, 0, 0.3], ...     distance=400, coa_phase=0, ...     delta_t=1/4096, f_lower=20, f_ref=20, mode=(2, 2) ... ) h.shape (16221,)</p>"},{"location":"api/models/#qcextender.models.lal_mode","title":"<code>lal_mode(approximant, mass1, mass2, spin1, spin2, distance, coa_phase, delta_t, f_lower, f_ref, mode)</code>","text":"<p>Generate a single gravitational-wave mode using LALSimulation. Wraps <code>lalsimulation.SimInspiralTDModesFromPolarizations</code>.</p> <pre><code>Args:\n    approximant (str): Name of the LALSimulation approximant (e.g. \"IMRPhenomD\").\n    mass1 (float): Primary mass [solar masses].\n    mass2 (float): Secondary mass [solar masses].\n    spin1 (array-like): Dimensionless spin vector (S1x, S1y, S1z).\n    spin2 (array-like): Dimensionless spin vector (S2x, S2y, S2z).\n    distance (float): Luminosity distance to source [megaparsecs].\n    coa_phase (float): Coalescence phase [radians].\n    delta_t (float): Sampling interval [seconds].\n    f_lower (float): Lower frequency cutoff [Hz].\n    f_ref (float): Reference frequency [Hz].\n    mode (tuple[int, int]): Mode (l, m) to extract.\n\nReturns:\n    tuple[np.ndarray, np.ndarray]:\n        - time (np.ndarray): Time samples [seconds].\n        - h (np.ndarray): Complex strain for the specified mode.\n</code></pre> Source code in <code>src/qcextender/models.py</code> <pre><code>def lal_mode(\n    approximant: str,\n    mass1: float,\n    mass2: float,\n    spin1: np.ndarray | list[float],\n    spin2: np.ndarray | list[float],\n    distance: float,\n    coa_phase: float,\n    delta_t: float,\n    f_lower: float,\n    f_ref: float,\n    mode: tuple[int, int],\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Generate a single gravitational-wave mode using LALSimulation. Wraps\n    `      lalsimulation.SimInspiralTDModesFromPolarizations`.\n\n        Args:\n            approximant (str): Name of the LALSimulation approximant (e.g. \"IMRPhenomD\").\n            mass1 (float): Primary mass [solar masses].\n            mass2 (float): Secondary mass [solar masses].\n            spin1 (array-like): Dimensionless spin vector (S1x, S1y, S1z).\n            spin2 (array-like): Dimensionless spin vector (S2x, S2y, S2z).\n            distance (float): Luminosity distance to source [megaparsecs].\n            coa_phase (float): Coalescence phase [radians].\n            delta_t (float): Sampling interval [seconds].\n            f_lower (float): Lower frequency cutoff [Hz].\n            f_ref (float): Reference frequency [Hz].\n            mode (tuple[int, int]): Mode (l, m) to extract.\n\n        Returns:\n            tuple[np.ndarray, np.ndarray]:\n                - time (np.ndarray): Time samples [seconds].\n                - h (np.ndarray): Complex strain for the specified mode.\n    \"\"\"\n    long_asc_nodes = 0.0\n    eccentricity = 0.0\n    mean_per_ano = 0.0\n    lal_pars = None\n\n    generateTD = ls.SimInspiralTDModesFromPolarizations(  # ls.SimInspiralTD\n        mass1 * MSUN_SI,\n        mass2 * MSUN_SI,\n        spin1[0],\n        spin1[1],\n        spin1[2],\n        spin2[0],\n        spin2[1],\n        spin2[2],\n        distance * 1e6 * PC_SI,\n        coa_phase,\n        long_asc_nodes,\n        eccentricity,\n        mean_per_ano,\n        delta_t,\n        f_lower,\n        f_ref,\n        lal_pars,\n        eval(\"ls.\" + str(approximant)),\n    )\n\n    hlal = ls.SphHarmTimeSeriesGetMode(generateTD, mode[0], mode[1])\n    h = hlal.data.data\n    time = np.arange(hlal.data.length) * hlal.deltaT\n\n    return time, h\n</code></pre>"},{"location":"api/units/","title":"Units","text":""},{"location":"api/units/#qcextender.units","title":"<code>qcextender.units</code>","text":"<p>Utility module for converting between geometric units and SI units.</p> <p>All functions assume geometric units with G = c = 1 unless otherwise noted. Conversions are provided for time, frequency, and strain. Each conversion has a corresponding inverse, ensuring round-trip consistency.</p> Constants <p>MTSUN_SI (float): Solar mass in seconds. PC_SI (float): Parsec in meters. C_SI (float): Speed of light in m/s.</p> Example <p>from qcextender import units units.tM_to_tSI(100, 30) 0.0147764728429238</p>"},{"location":"api/units/#qcextender.units.tM_to_tSI","title":"<code>tM_to_tSI(time, total_mass)</code>","text":"<p>Convert geometric time (units of M) into SI seconds.</p> <p>Inverse of <code>tSI_to_tM</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>array - like or float</code> <p>Time in geometric units (M).</p> required <code>total_mass</code> <code>float</code> <p>Total mass of the system [solar masses].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Time in seconds.</p> Source code in <code>src/qcextender/units.py</code> <pre><code>def tM_to_tSI(time: np.ndarray | Number, total_mass: Number) -&gt; np.ndarray:\n    \"\"\"Convert geometric time (units of M) into SI seconds.\n\n    Inverse of `tSI_to_tM`.\n\n    Args:\n        time (array-like or float): Time in geometric units (M).\n        total_mass (float): Total mass of the system [solar masses].\n\n    Returns:\n        np.ndarray: Time in seconds.\n    \"\"\"\n    return time * (MTSUN_SI * total_mass)\n</code></pre>"},{"location":"api/units/#qcextender.units.tSI_to_tM","title":"<code>tSI_to_tM(time, total_mass)</code>","text":"<p>Convert SI seconds into geometric time (units of M).</p> <p>Inverse of <code>tM_to_tSI</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>array - like or float</code> <p>Time in seconds.</p> required <code>total_mass</code> <code>float</code> <p>Total mass of the system [solar masses].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Time in geometric units (M).</p> Source code in <code>src/qcextender/units.py</code> <pre><code>def tSI_to_tM(time: np.ndarray | Number, total_mass: Number) -&gt; np.ndarray:\n    \"\"\"Convert SI seconds into geometric time (units of M).\n\n    Inverse of `tM_to_tSI`.\n\n    Args:\n        time (array-like or float): Time in seconds.\n        total_mass (float): Total mass of the system [solar masses].\n\n    Returns:\n        np.ndarray: Time in geometric units (M).\n    \"\"\"\n    return time / (MTSUN_SI * total_mass)\n</code></pre>"},{"location":"api/units/#qcextender.units.fM_to_fSI","title":"<code>fM_to_fSI(frequency, total_mass)</code>","text":"<p>Convert geometric frequency (units of 1/M) into SI hertz.</p> <p>Inverse of <code>fSI_to_fM</code>.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>array - like or float</code> <p>Frequency in geometric units (1/M).</p> required <code>total_mass</code> <code>float</code> <p>Total mass of the system [solar masses].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Frequency in hertz.</p> Source code in <code>src/qcextender/units.py</code> <pre><code>def fM_to_fSI(frequency: np.ndarray | Number, total_mass: Number) -&gt; np.ndarray:\n    \"\"\"Convert geometric frequency (units of 1/M) into SI hertz.\n\n    Inverse of `fSI_to_fM`.\n\n    Args:\n        frequency (array-like or float): Frequency in geometric units (1/M).\n        total_mass (float): Total mass of the system [solar masses].\n\n    Returns:\n        np.ndarray: Frequency in hertz.\n    \"\"\"\n    return frequency / (MTSUN_SI * total_mass)\n</code></pre>"},{"location":"api/units/#qcextender.units.fSI_to_fM","title":"<code>fSI_to_fM(frequency, total_mass)</code>","text":"<p>Convert SI hertz into geometric frequency (units of 1/M).</p> <p>Inverse of <code>fM_to_fSI</code>.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>array - like or float</code> <p>Frequency in hertz.</p> required <code>total_mass</code> <code>float</code> <p>Total mass of the system [solar masses].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Frequency in geometric units (1/M).</p> Source code in <code>src/qcextender/units.py</code> <pre><code>def fSI_to_fM(frequency: np.ndarray | Number, total_mass: Number) -&gt; np.ndarray:\n    \"\"\"Convert SI hertz into geometric frequency (units of 1/M).\n\n    Inverse of `fM_to_fSI`.\n\n    Args:\n        frequency (array-like or float): Frequency in hertz.\n        total_mass (float): Total mass of the system [solar masses].\n\n    Returns:\n        np.ndarray: Frequency in geometric units (1/M).\n    \"\"\"\n    return frequency * (MTSUN_SI * total_mass)\n</code></pre>"},{"location":"api/units/#qcextender.units.mM_to_mSI","title":"<code>mM_to_mSI(strain, total_mass, distance)</code>","text":"<p>Convert geometric strain amplitude into SI strain at a given distance.</p> <p>Inverse of <code>mSI_to_mM</code>.</p> <p>Parameters:</p> Name Type Description Default <code>strain</code> <code>array - like or float</code> <p>Dimensionless strain in geometric units.</p> required <code>total_mass</code> <code>float</code> <p>Total mass of the system [solar masses].</p> required <code>distance</code> <code>float</code> <p>Luminosity distance to source [megaparsecs].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Equivalent displacement amplitude in SI units (meters).</p> Source code in <code>src/qcextender/units.py</code> <pre><code>def mM_to_mSI(\n    strain: np.ndarray | Number, total_mass: Number, distance: Number\n) -&gt; np.ndarray:\n    \"\"\"Convert geometric strain amplitude into SI strain at a given distance.\n\n    Inverse of `mSI_to_mM`.\n\n    Args:\n        strain (array-like or float): Dimensionless strain in geometric units.\n        total_mass (float): Total mass of the system [solar masses].\n        distance (float): Luminosity distance to source [megaparsecs].\n\n    Returns:\n        np.ndarray: Equivalent displacement amplitude in SI units (meters).\n    \"\"\"\n    return strain * total_mass * MTSUN_SI * C_SI / (distance * 1e6 * PC_SI)\n</code></pre>"},{"location":"api/units/#qcextender.units.mSI_to_mM","title":"<code>mSI_to_mM(strain, total_mass, distance)</code>","text":"<p>Convert SI strain amplitude into geometric strain at a given distance.</p> <p>Inverse of <code>mM_to_mSI</code>.</p> <p>Parameters:</p> Name Type Description Default <code>strain</code> <code>array - like or float</code> <p>Equivalent displacement amplitude in SI units (meters).</p> required <code>total_mass</code> <code>float</code> <p>Total mass of the system [solar masses].</p> required <code>distance</code> <code>float</code> <p>Luminosity distance to source [megaparsecs].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Dimensionless strain in geometric units.</p> Source code in <code>src/qcextender/units.py</code> <pre><code>def mSI_to_mM(\n    strain: np.ndarray | Number, total_mass: Number, distance: Number\n) -&gt; np.ndarray:\n    \"\"\"Convert SI strain amplitude into geometric strain at a given distance.\n\n    Inverse of `mM_to_mSI`.\n\n    Args:\n        strain (array-like or float): Equivalent displacement amplitude in SI units (meters).\n        total_mass (float): Total mass of the system [solar masses].\n        distance (float): Luminosity distance to source [megaparsecs].\n\n    Returns:\n        np.ndarray: Dimensionless strain in geometric units.\n    \"\"\"\n    return strain / (total_mass * MTSUN_SI * C_SI / (distance * 1e6 * PC_SI))\n</code></pre>"},{"location":"api/waveform/","title":"Waveform","text":"<p>               Bases: <code>BaseWaveform</code></p> <p>Class representing multi-modal time-domain gravitational waveforms.</p> <p>The :class:<code>Waveform</code> class extends :class:<code>BaseWaveform</code> and provides utilities for generation, manipulation, and comparison of gravitational waveforms. Each waveform may consist of multiple spin-weighted spherical-harmonic modes.</p> <p>Attributes:</p> Name Type Description <code>strain</code> <code>ndarray</code> <p>Stacked complex strain data for each mode.</p> <code>time</code> <code>ndarray</code> <p>Time array corresponding to the waveform.</p> <code>metadata</code> <code>Metadata</code> <p>Object storing waveform parameters and provenance.</p> Source code in <code>src/qcextender/waveform.py</code> <pre><code>class Waveform(BaseWaveform):\n    \"\"\"Class representing multi-modal time-domain gravitational waveforms.\n\n    The :class:`Waveform` class extends :class:`BaseWaveform` and provides utilities for generation, manipulation, and comparison of gravitational\n    waveforms. Each waveform may consist of multiple spin-weighted spherical-harmonic modes.\n\n    Attributes:\n        strain (np.ndarray): Stacked complex strain data for each mode.\n        time (np.ndarray): Time array corresponding to the waveform.\n        metadata (Metadata): Object storing waveform parameters and provenance.\n    \"\"\"\n\n    def __init__(\n        self, strain: np.ndarray, time: np.ndarray, metadata: Metadata\n    ) -&gt; None:\n        \"\"\"Initializes a waveform object with given strain, time, and metadata.\n\n        Args:\n            strain (np.ndarray): Stacked array of mode strains, one per (l, m) mode.\n            time (np.ndarray): Time array of uniform spacing.\n            metadata (Metadata): Metadata containing waveform parameters.\n        \"\"\"\n        super().__init__(strain, time, metadata)\n\n    @classmethod\n    def from_model(\n        cls, approximant: str, modes: list[tuple[int, int]] = [(2, 2)], **kwargs\n    ) -&gt; Self:\n        \"\"\"Generates a time-domain waveform from a given approximant.\n\n        Uses LALSimulation models (via :func:`lal_mode`) to generate specified\n        modes and combines them into a multi-modal waveform.\n\n        Args:\n            approximant (str): LALSimulation waveform approximant name (e.g. \"IMRPhenomD\").\n            modes (list[tuple[int, int]], optional): List of (l, m) mode indices to include. Defaults to ``[(2, 2)]``.\n            **kwargs: Additional parameters required by the model, such as ``mass1``, ``mass2``, ``spin1``, ``spin2``, ``distance``, ``coa_phase``,\n            ``delta_t``, ``f_lower``, and ``f_ref``.\n\n        Raises:\n            ValueError: If a requested approximant is not made available.\n\n        Returns:\n            Waveform: The generated waveform object containing the stacked strain data.\n        \"\"\"\n        total_mass = kwargs[\"mass1\"] + kwargs[\"mass2\"]\n\n        q = kwargs[\"mass1\"] / kwargs[\"mass2\"]\n        if q &lt; 1:\n            q = 1 / q\n\n        kwargs.update(\n            library=\"lalsimulation\",\n            q=q,\n            approximant=approximant,\n            modes=list(modes),\n            total_mass=total_mass,\n        )\n        metadata = cls._kwargs_to_metadata(kwargs)\n\n        single_mode_strain = []\n        if approximant in [\"IMRPhenomD\", \"SEOBNRv4\"]:\n            for mode in modes:\n                time, strain = lal_mode(\n                    approximant,\n                    kwargs[\"mass1\"],\n                    kwargs[\"mass2\"],\n                    metadata[\"spin1\"],\n                    metadata[\"spin2\"],\n                    metadata[\"distance\"],\n                    metadata[\"coa_phase\"],\n                    metadata[\"delta_t\"],\n                    metadata[\"f_lower\"],\n                    kwargs[\"f_ref\"],\n                    mode,\n                )\n            single_mode_strain.append(strain)\n        else:\n            raise ValueError(\n                f\"{approximant} not explicitly supported, please add support.\"\n            )\n\n        multi_mode_strain = np.vstack(single_mode_strain)\n        time = cls._align(single_mode_strain[0], time)\n\n        return cls(\n            multi_mode_strain,\n            time,\n            metadata,\n        )\n\n    def match(\n        self,\n        waveform: Self,\n        f_lower: float | None = None,\n        psd: str = \"aLIGOZeroDetHighPower\",\n    ) -&gt; float:\n        \"\"\"Computes the normalized overlap (match) between two waveforms.\n\n        The match quantifies similarity between two real-valued time-domain waveforms, taking into account their noise-weighted inner product\n        under a given power spectral density (PSD).\n\n        Args:\n            waveform (Self): Second waveform to compare with ``self``.\n            f_lower (float | None, optional): Low-frequency cutoff for the match. Defaults to ``None``, which uses the higher of both waveforms' ``f_lower``.\n            psd (str, optional): PSD name. Currently only PyCBC PSD names are supported. Defaults to ``\"aLIGOZeroDetHighPower\"``.\n\n        Returns:\n            float: The computed match value between 0 and 1.\n        \"\"\"\n        delta_t = max(self.metadata.delta_t, waveform.metadata.delta_t)\n        wf1_time = np.arange(self.time[0], self.time[-1], delta_t)\n        wf2_time = np.arange(waveform.time[0], waveform.time[-1], delta_t)\n\n        wf1_strain = self.recombine_strain(wf1_time)\n        wf2_strain = waveform.recombine_strain(wf2_time)\n\n        wf1 = ts.TimeSeries(wf1_strain.real, delta_t=delta_t)\n        wf2 = ts.TimeSeries(wf2_strain.real, delta_t=delta_t)\n\n        if f_lower is None:\n            f_lower = max(self.metadata.f_lower, waveform.metadata.f_lower)\n\n        flen = 1 &lt;&lt; (max(len(wf1), len(wf2)) - 1).bit_length()\n        delta_f = 1.0 / (flen * delta_t)\n\n        psd = aLIGOZeroDetHighPower(flen, delta_f, f_lower)\n        wf1.resize(flen)\n        wf2.resize(flen)\n\n        return cbcmatch(wf1, wf2, psd=psd, low_frequency_cutoff=f_lower)[0]\n\n    def freq(self) -&gt; np.ndarray:\n        \"\"\"Converts the waveform to the frequency domain.\n\n        Returns:\n            FrequencySeries: PyCBC's built-in frequency-domain representation (complex frequency series).\n        \"\"\"\n        delta_t = self.metadata.delta_t\n        wf = ts.TimeSeries(self.recombine_strain().real, delta_t=delta_t)\n\n        wfreq = wf.to_frequencyseries()\n        return wfreq\n\n    def add_eccentricity(\n        self,\n        func: callable,\n        eccentricity: float,\n        modes: list[tuple[int, int]] = [(2, 2)],\n        **kwargs,\n    ):\n        \"\"\"Applies an eccentricity correction to the waveform.\n\n        The correction function is user-supplied and returns time, phase, and amplitude. The waveform strain is reconstructed from these components.\n\n        Args:\n            func (callable): Function that takes the waveform and mode, returning ``(time, phase, amplitude)``.\n            eccentricity (float): Eccentricity value to assign to the new waveform.\n            modes (list[tuple[int, int]], optional): Modes to modify. Defaults to ``[(2, 2)]``.\n            **kwargs: Additional parameters for the supplied function.\n\n        Returns:\n            Waveform: New waveform instance with updated eccentricity and modes.\n        \"\"\"\n        strain = []\n        for mode in modes:\n            time, phase, amplitude = func(self, mode, **kwargs)\n            strain.append(amplitude * np.exp(1j * phase))\n\n        metadata = self.metadata.copy()\n        metadata.modes = modes\n        metadata.eccentricity = eccentricity\n        return Waveform(np.vstack(strain), time, metadata)\n</code></pre>"},{"location":"api/waveform/#qcextender.waveform.Waveform.__init__","title":"<code>__init__(strain, time, metadata)</code>","text":"<p>Initializes a waveform object with given strain, time, and metadata.</p> <p>Parameters:</p> Name Type Description Default <code>strain</code> <code>ndarray</code> <p>Stacked array of mode strains, one per (l, m) mode.</p> required <code>time</code> <code>ndarray</code> <p>Time array of uniform spacing.</p> required <code>metadata</code> <code>Metadata</code> <p>Metadata containing waveform parameters.</p> required Source code in <code>src/qcextender/waveform.py</code> <pre><code>def __init__(\n    self, strain: np.ndarray, time: np.ndarray, metadata: Metadata\n) -&gt; None:\n    \"\"\"Initializes a waveform object with given strain, time, and metadata.\n\n    Args:\n        strain (np.ndarray): Stacked array of mode strains, one per (l, m) mode.\n        time (np.ndarray): Time array of uniform spacing.\n        metadata (Metadata): Metadata containing waveform parameters.\n    \"\"\"\n    super().__init__(strain, time, metadata)\n</code></pre>"},{"location":"api/waveform/#qcextender.waveform.Waveform.add_eccentricity","title":"<code>add_eccentricity(func, eccentricity, modes=[(2, 2)], **kwargs)</code>","text":"<p>Applies an eccentricity correction to the waveform.</p> <p>The correction function is user-supplied and returns time, phase, and amplitude. The waveform strain is reconstructed from these components.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Function that takes the waveform and mode, returning <code>(time, phase, amplitude)</code>.</p> required <code>eccentricity</code> <code>float</code> <p>Eccentricity value to assign to the new waveform.</p> required <code>modes</code> <code>list[tuple[int, int]]</code> <p>Modes to modify. Defaults to <code>[(2, 2)]</code>.</p> <code>[(2, 2)]</code> <code>**kwargs</code> <p>Additional parameters for the supplied function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Waveform</code> <p>New waveform instance with updated eccentricity and modes.</p> Source code in <code>src/qcextender/waveform.py</code> <pre><code>def add_eccentricity(\n    self,\n    func: callable,\n    eccentricity: float,\n    modes: list[tuple[int, int]] = [(2, 2)],\n    **kwargs,\n):\n    \"\"\"Applies an eccentricity correction to the waveform.\n\n    The correction function is user-supplied and returns time, phase, and amplitude. The waveform strain is reconstructed from these components.\n\n    Args:\n        func (callable): Function that takes the waveform and mode, returning ``(time, phase, amplitude)``.\n        eccentricity (float): Eccentricity value to assign to the new waveform.\n        modes (list[tuple[int, int]], optional): Modes to modify. Defaults to ``[(2, 2)]``.\n        **kwargs: Additional parameters for the supplied function.\n\n    Returns:\n        Waveform: New waveform instance with updated eccentricity and modes.\n    \"\"\"\n    strain = []\n    for mode in modes:\n        time, phase, amplitude = func(self, mode, **kwargs)\n        strain.append(amplitude * np.exp(1j * phase))\n\n    metadata = self.metadata.copy()\n    metadata.modes = modes\n    metadata.eccentricity = eccentricity\n    return Waveform(np.vstack(strain), time, metadata)\n</code></pre>"},{"location":"api/waveform/#qcextender.waveform.Waveform.freq","title":"<code>freq()</code>","text":"<p>Converts the waveform to the frequency domain.</p> <p>Returns:</p> Name Type Description <code>FrequencySeries</code> <code>ndarray</code> <p>PyCBC's built-in frequency-domain representation (complex frequency series).</p> Source code in <code>src/qcextender/waveform.py</code> <pre><code>def freq(self) -&gt; np.ndarray:\n    \"\"\"Converts the waveform to the frequency domain.\n\n    Returns:\n        FrequencySeries: PyCBC's built-in frequency-domain representation (complex frequency series).\n    \"\"\"\n    delta_t = self.metadata.delta_t\n    wf = ts.TimeSeries(self.recombine_strain().real, delta_t=delta_t)\n\n    wfreq = wf.to_frequencyseries()\n    return wfreq\n</code></pre>"},{"location":"api/waveform/#qcextender.waveform.Waveform.from_model","title":"<code>from_model(approximant, modes=[(2, 2)], **kwargs)</code>  <code>classmethod</code>","text":"<p>Generates a time-domain waveform from a given approximant.</p> <p>Uses LALSimulation models (via :func:<code>lal_mode</code>) to generate specified modes and combines them into a multi-modal waveform.</p> <p>Parameters:</p> Name Type Description Default <code>approximant</code> <code>str</code> <p>LALSimulation waveform approximant name (e.g. \"IMRPhenomD\").</p> required <code>modes</code> <code>list[tuple[int, int]]</code> <p>List of (l, m) mode indices to include. Defaults to <code>[(2, 2)]</code>.</p> <code>[(2, 2)]</code> <code>**kwargs</code> <p>Additional parameters required by the model, such as <code>mass1</code>, <code>mass2</code>, <code>spin1</code>, <code>spin2</code>, <code>distance</code>, <code>coa_phase</code>,</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a requested approximant is not made available.</p> <p>Returns:</p> Name Type Description <code>Waveform</code> <code>Self</code> <p>The generated waveform object containing the stacked strain data.</p> Source code in <code>src/qcextender/waveform.py</code> <pre><code>@classmethod\ndef from_model(\n    cls, approximant: str, modes: list[tuple[int, int]] = [(2, 2)], **kwargs\n) -&gt; Self:\n    \"\"\"Generates a time-domain waveform from a given approximant.\n\n    Uses LALSimulation models (via :func:`lal_mode`) to generate specified\n    modes and combines them into a multi-modal waveform.\n\n    Args:\n        approximant (str): LALSimulation waveform approximant name (e.g. \"IMRPhenomD\").\n        modes (list[tuple[int, int]], optional): List of (l, m) mode indices to include. Defaults to ``[(2, 2)]``.\n        **kwargs: Additional parameters required by the model, such as ``mass1``, ``mass2``, ``spin1``, ``spin2``, ``distance``, ``coa_phase``,\n        ``delta_t``, ``f_lower``, and ``f_ref``.\n\n    Raises:\n        ValueError: If a requested approximant is not made available.\n\n    Returns:\n        Waveform: The generated waveform object containing the stacked strain data.\n    \"\"\"\n    total_mass = kwargs[\"mass1\"] + kwargs[\"mass2\"]\n\n    q = kwargs[\"mass1\"] / kwargs[\"mass2\"]\n    if q &lt; 1:\n        q = 1 / q\n\n    kwargs.update(\n        library=\"lalsimulation\",\n        q=q,\n        approximant=approximant,\n        modes=list(modes),\n        total_mass=total_mass,\n    )\n    metadata = cls._kwargs_to_metadata(kwargs)\n\n    single_mode_strain = []\n    if approximant in [\"IMRPhenomD\", \"SEOBNRv4\"]:\n        for mode in modes:\n            time, strain = lal_mode(\n                approximant,\n                kwargs[\"mass1\"],\n                kwargs[\"mass2\"],\n                metadata[\"spin1\"],\n                metadata[\"spin2\"],\n                metadata[\"distance\"],\n                metadata[\"coa_phase\"],\n                metadata[\"delta_t\"],\n                metadata[\"f_lower\"],\n                kwargs[\"f_ref\"],\n                mode,\n            )\n        single_mode_strain.append(strain)\n    else:\n        raise ValueError(\n            f\"{approximant} not explicitly supported, please add support.\"\n        )\n\n    multi_mode_strain = np.vstack(single_mode_strain)\n    time = cls._align(single_mode_strain[0], time)\n\n    return cls(\n        multi_mode_strain,\n        time,\n        metadata,\n    )\n</code></pre>"},{"location":"api/waveform/#qcextender.waveform.Waveform.match","title":"<code>match(waveform, f_lower=None, psd='aLIGOZeroDetHighPower')</code>","text":"<p>Computes the normalized overlap (match) between two waveforms.</p> <p>The match quantifies similarity between two real-valued time-domain waveforms, taking into account their noise-weighted inner product under a given power spectral density (PSD).</p> <p>Parameters:</p> Name Type Description Default <code>waveform</code> <code>Self</code> <p>Second waveform to compare with <code>self</code>.</p> required <code>f_lower</code> <code>float | None</code> <p>Low-frequency cutoff for the match. Defaults to <code>None</code>, which uses the higher of both waveforms' <code>f_lower</code>.</p> <code>None</code> <code>psd</code> <code>str</code> <p>PSD name. Currently only PyCBC PSD names are supported. Defaults to <code>\"aLIGOZeroDetHighPower\"</code>.</p> <code>'aLIGOZeroDetHighPower'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The computed match value between 0 and 1.</p> Source code in <code>src/qcextender/waveform.py</code> <pre><code>def match(\n    self,\n    waveform: Self,\n    f_lower: float | None = None,\n    psd: str = \"aLIGOZeroDetHighPower\",\n) -&gt; float:\n    \"\"\"Computes the normalized overlap (match) between two waveforms.\n\n    The match quantifies similarity between two real-valued time-domain waveforms, taking into account their noise-weighted inner product\n    under a given power spectral density (PSD).\n\n    Args:\n        waveform (Self): Second waveform to compare with ``self``.\n        f_lower (float | None, optional): Low-frequency cutoff for the match. Defaults to ``None``, which uses the higher of both waveforms' ``f_lower``.\n        psd (str, optional): PSD name. Currently only PyCBC PSD names are supported. Defaults to ``\"aLIGOZeroDetHighPower\"``.\n\n    Returns:\n        float: The computed match value between 0 and 1.\n    \"\"\"\n    delta_t = max(self.metadata.delta_t, waveform.metadata.delta_t)\n    wf1_time = np.arange(self.time[0], self.time[-1], delta_t)\n    wf2_time = np.arange(waveform.time[0], waveform.time[-1], delta_t)\n\n    wf1_strain = self.recombine_strain(wf1_time)\n    wf2_strain = waveform.recombine_strain(wf2_time)\n\n    wf1 = ts.TimeSeries(wf1_strain.real, delta_t=delta_t)\n    wf2 = ts.TimeSeries(wf2_strain.real, delta_t=delta_t)\n\n    if f_lower is None:\n        f_lower = max(self.metadata.f_lower, waveform.metadata.f_lower)\n\n    flen = 1 &lt;&lt; (max(len(wf1), len(wf2)) - 1).bit_length()\n    delta_f = 1.0 / (flen * delta_t)\n\n    psd = aLIGOZeroDetHighPower(flen, delta_f, f_lower)\n    wf1.resize(flen)\n    wf2.resize(flen)\n\n    return cbcmatch(wf1, wf2, psd=psd, low_frequency_cutoff=f_lower)[0]\n</code></pre>"}]}